const SHEET_ID = "1YEqS1zEf-ej7lfqLIpej6j2YXbAgCES3VC_2ODH721Y";
// FOLDER_ID ไม่ได้ใช้แล้ว แต่เก็บไว้เผื่ออนาคต
// const FOLDER_ID = "1jJ_1IfvfzyEonA_JzBFI5nu460JGYgHZ"; 
const SHEET_NAME = "ข้อมูลการมาเรียน";

function doGet(e) {
  const action = e.parameter.action;
  if (action === 'read') {
    return readData();
  }
  return ContentService.createTextOutput(JSON.stringify({status: "error", message: "Invalid GET action"}))
                     .setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  try {
    const action = e.parameter.action;
    let response;
    switch (action) {
      case 'create':
        response = createRecord(e.parameter);
        break;
      case 'updateAttendance':
        response = updateAttendanceRecord(e.parameter);
        break;
      case 'delete':
        response = deleteRecord(e.parameter);
        break;
      default:
        response = { status: 'error', message: 'Invalid POST action specified.' };
    }
    return ContentService.createTextOutput(JSON.stringify(response))
                       .setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    Logger.log("Error in doPost: " + error.toString() + "\nStack: " + error.stack);
    return ContentService.createTextOutput(JSON.stringify({ status: 'error', message: error.message, details: error.stack }))
                       .setMimeType(ContentService.MimeType.JSON);
  }
}

function getOrCreateSheet(sheetName) {
  const ss = SpreadsheetApp.openById(SHEET_ID);
  let sheet = ss.getSheetByName(sheetName);
  const expectedHeaders = [ // Removed ProfilePicURL, DocumentJSON, ImageJSON
    "RowID", "Timestamp", "Level", "Classroom", "StudentNumber", "StudentID", "FullName", "Nickname",
    "AttendanceDate", "AttendanceType", "AttendanceOccurrence",
    "AbsenceCategory", "AbsenceDetailContinuous", "AbsenceDetailNonContinuous", "LateDetail",
    "FollowUpActions", "FollowUpStatus", "Notes"
  ];

  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
    sheet.clearContents(); 
    if (sheet.getMaxRows() > 1) sheet.deleteRows(1, sheet.getMaxRows() -1 );
    // Ensure at least one column for appendRow even if expectedHeaders is empty (though it's not)
    if (sheet.getMaxColumns() === 0 && expectedHeaders.length > 0) {
        sheet.insertColumns(1, expectedHeaders.length);
    } else if (sheet.getMaxColumns() > 1 && sheet.getMaxColumns() > expectedHeaders.length) {
         sheet.deleteColumns(expectedHeaders.length + 1, sheet.getMaxColumns() - expectedHeaders.length);
    } else if (sheet.getMaxColumns() > 1 && sheet.getMaxColumns() < expectedHeaders.length) {
         sheet.insertColumns(sheet.getMaxColumns() + 1, expectedHeaders.length - sheet.getMaxColumns());
    }


    sheet.appendRow(expectedHeaders);
    sheet.getRange(1, 1, 1, expectedHeaders.length).setFontWeight("bold");
  } else {
    let currentHeaders = [];
    if (sheet.getLastRow() > 0 && sheet.getLastColumn() > 0) {
        currentHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    }
    let headersMatch = currentHeaders.length === expectedHeaders.length;
    if (headersMatch) {
      for (let i = 0; i < expectedHeaders.length; i++) {
        if (currentHeaders[i] !== expectedHeaders[i]) {
          headersMatch = false;
          break;
        }
      }
    }
    if (!headersMatch) {
      Logger.log("Header mismatch or sheet was empty. Resetting headers for sheet: " + sheetName);
      sheet.getRange(1, 1, 1, Math.max(currentHeaders.length, expectedHeaders.length)).clearContent();
      sheet.getRange(1, 1, 1, expectedHeaders.length).setValues([expectedHeaders]).setFontWeight("bold");
      if (currentHeaders.length > expectedHeaders.length) {
        sheet.deleteColumns(expectedHeaders.length + 1, currentHeaders.length - expectedHeaders.length);
      }
    }
  }
  SpreadsheetApp.flush();
  return sheet;
}

// uploadSingleFileToDrive is no longer called by createRecord, but can be kept for other uses
function uploadSingleFileToDrive(fileDataString, folderId, imageTypeFormat = false) {
  if (!fileDataString || fileDataString === '{}' || fileDataString === 'null') {
    return null; 
  }
  try {
    const folder = DriveApp.getFolderById(folderId); // Get folder inside function
    const fileObj = JSON.parse(fileDataString); 
    if (fileObj && fileObj.base64 && fileObj.type && fileObj.name) {
      const decoded = Utilities.base64Decode(fileObj.base64, Utilities.Charset.UTF_8);
      const blob = Utilities.newBlob(decoded, fileObj.type, fileObj.name);
      const file = folder.createFile(blob);
      let fileUrl = file.getUrl();
      if (imageTypeFormat) { 
        file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
        fileUrl = `https://drive.google.com/uc?export=view&id=${file.getId()}`;
      }
      return JSON.stringify({ name: fileObj.name, url: fileUrl, type: fileObj.type });
    }
    return null;
  } catch (e) {
    Logger.log("Error in uploadSingleFileToDrive: " + e.toString() + " Input: " + fileDataString);
    return null;
  }
}

function createRecord(params) {
  const sheet = getOrCreateSheet(SHEET_NAME);
  // No file uploads in this version
  // const profilePicJSON = null; 
  // const documentJSON = null;
  // const imageJSON = null;

  const lastRow = sheet.getLastRow();
  let maxId = 0;
  if (lastRow > 1) {
    const idsData = sheet.getRange(2, 1, Math.max(1, lastRow - 1), 1).getValues();
    maxId = idsData.reduce((max, row) => {
      const currentId = parseInt(row[0], 10);
      return !isNaN(currentId) ? Math.max(max, currentId) : max;
    }, 0);
  }
  const newRowId = maxId + 1;

  const newRowData = [
    newRowId, new Date(), params.level, params.classroom, params.studentNumber, params.studentId,
    params.fullName, params.nickname || "", // Removed profilePicJSON placeholder
    params.attendanceDate, params.attendanceType, params.attendanceOccurrence,
    params.absenceCategory || "", params.absenceDetailContinuous || "", params.absenceDetailNonContinuous || "", params.lateDetail || "",
    params.followUpActions || "[]", params.followUpStatus || "ระหว่างดำเนินการ",
    params.notes || "" // Removed documentJSON, imageJSON placeholders
  ];
  // Adjust appendRow if number of headers changed
   const expectedHeaderCount = getOrCreateSheet(SHEET_NAME).getRange(1,1,1,getOrCreateSheet(SHEET_NAME).getLastColumn()).getValues()[0].length;
   if (newRowData.length !== expectedHeaderCount) {
       Logger.log("Mismatch between newRowData length (" + newRowData.length + ") and expectedHeaderCount (" + expectedHeaderCount + ")");
       // Potentially pad newRowData with empty strings or handle error
       // For now, this assumes newRowData length matches expectedHeaders
   }

  sheet.appendRow(newRowData);
  return { status: 'success', message: 'บันทึกข้อมูลเรียบร้อย (ไม่รวมไฟล์แนบ)', newRowId: newRowId };
}

function readData() {
  const sheet = getOrCreateSheet(SHEET_NAME);
  if (sheet.getLastRow() < 2) {
    return ContentService.createTextOutput(JSON.stringify([])).setMimeType(ContentService.MimeType.JSON);
  }
  const lastCol = sheet.getLastColumn();
  const headers = sheet.getRange(1, 1, 1, lastCol).getValues()[0];
  const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, lastCol);
  const data = dataRange.getValues();

  const results = data.map(row => {
    let obj = {};
    headers.forEach((header, index) => {
      let value = row[index];
      if (header === "AttendanceDate" && value instanceof Date) {
        value = Utilities.formatDate(value, Session.getScriptTimeZone(), "yyyy-MM-dd");
      }
      // Try to parse fields that were previously JSON, but default to null or [] if missing or error
      if (["FollowUpActions", "DocumentJSON", "ImageJSON", "ProfilePicURL"].includes(header)) {
        try {
          if (value && typeof value === 'string') { 
            obj[header] = JSON.parse(value);
          } else if (value) { 
             obj[header] = value; // Should not happen if from sheet and was string
          } else { 
            obj[header] = (header === "FollowUpActions" ? [] : null); 
          }
        } catch (e) {
          obj[header] = (header === "FollowUpActions" ? [] : null); 
        }
      } else {
        obj[header] = value;
      }
    });
    return obj;
  });
  return ContentService.createTextOutput(JSON.stringify(results)).setMimeType(ContentService.MimeType.JSON);
}

function findRowIndexByRowID(sheet, rowId) {
  if (sheet.getLastRow() < 2) return -1;
  const ids = sheet.getRange(2, 1, sheet.getLastRow() - 1, 1).getValues();
  for (let i = 0; i < ids.length; i++) {
    if (ids[i][0] == rowId) {
      return i + 2;
    }
  }
  return -1;
}

function updateAttendanceRecord(params) {
  const sheet = getOrCreateSheet(SHEET_NAME);
  const rowId = parseInt(params.rowId, 10);
  const rowIndexToUpdate = findRowIndexByRowID(sheet, rowId);

  if (rowIndexToUpdate === -1) {
    return { status: 'error', message: 'ไม่พบข้อมูล (Row ID not found)' };
  }
  
  const headersFromSheet = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const setValueByHeader = (headerName, value, defaultValue = "") => {
    const colIndex = headersFromSheet.indexOf(headerName);
    if (colIndex !== -1) {
      sheet.getRange(rowIndexToUpdate, colIndex + 1).setValue(value || defaultValue);
    } else {
        // Logger.log("Header not found for update during edit: " + headerName); // Optional logging
    }
  };

  setValueByHeader("Level", params.level); 
  setValueByHeader("Classroom", params.classroom); 
  setValueByHeader("StudentNumber", params.studentNumber); 
  setValueByHeader("StudentID", params.studentId); 
  setValueByHeader("FullName", params.fullName); 
  setValueByHeader("Nickname", params.nickname || ""); 
  
  setValueByHeader("AttendanceDate", params.attendanceDate);
  setValueByHeader("AttendanceType", params.attendanceType);
  setValueByHeader("AttendanceOccurrence", params.attendanceOccurrence);
  setValueByHeader("AbsenceCategory", params.absenceCategory);
  setValueByHeader("AbsenceDetailContinuous", params.absenceDetailContinuous);
  setValueByHeader("AbsenceDetailNonContinuous", params.absenceDetailNonContinuous);
  setValueByHeader("LateDetail", params.lateDetail);
  setValueByHeader("FollowUpActions", params.followUpActions, "[]");
  setValueByHeader("FollowUpStatus", params.followUpStatus, "ระหว่างดำเนินการ");
  setValueByHeader("Notes", params.notes);
  
  return { status: 'success', message: 'อัปเดตข้อมูลเรียบร้อย' };
}

function deleteRecord(params) {
  const sheet = getOrCreateSheet(SHEET_NAME);
  const rowId = parseInt(params.rowId, 10);
  const rowIndexToDelete = findRowIndexByRowID(sheet, rowId);

  if (rowIndexToDelete !== -1) {
    sheet.deleteRow(rowIndexToDelete);
    return { status: 'success', message: 'ลบข้อมูลเรียบร้อย' };
  } else {
    return { status: 'error', message: 'ไม่พบข้อมูล (Row ID not found)' };
  }
}
